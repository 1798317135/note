
########################################## ddl #####################################

1.0 数据定义语言 
2.0 用来定义数据库对象：创建库，表，列表。
3.0 主要是修改数据库的结构


--- 创建数据库 后面加 字符集
    create database test character set utf8;

--- 使用数据库
    use xxx

--- 删除数据库
    drop database xxx

--- 创建表 
    create table xxx(
        id int,
        name varchar(25),
        age int,
        email varchar(255)
    );

--- 删除表
    drop table xxx

--- 修改表名 
    rename table 需要修改的表 to 要修改的名字

--- 添加列（字段）
    alter table 要添加的表 add 字段 类型;

--- 修改列名
    alter talbe 表名 change 原始名 新名字 数据类型；

--- 修改字段约束
    alter table t_user modify user_id int(10);

--- 删除列
    alter table 要删除的表 drop 字段名

--- 修改字符集
    alter tabel 修改的表 character set xxx;

--- 删除表
    drop table 表名

############################################# dml ####################################

1.0 数据操作语言： 
2.0 用来操作数据库表中的记录
3.0 对表中的数据进行增删改

--- 给指定的字段 添加多个列的值 用逗号隔开
    注意值要和 字段一一对应 并且数据类型 要匹配

    inert into 表明（字段1，字段2）vales(值1，值2),(值1，值2)

--- 更改字段的值
    如果不增加条件 则这个字段下的全部值 都会被改变

    update 表名 set 字段1 = 值1，字段2 = 值2；

--- 修改指定条件 字段的值
    update 表名 set 字段1 = 值1 where 条件

--- 删除指定条件 的一组 也就是一行
    删除表中的数据 表结构仍在
    delete from 表名 where 条件

--- 删掉全部内容
    delete from 表名

--- 删除全部字段的全部数据
    他会把整个表drop 掉 然后创建一个新表
    这个效率更高

    truncate table 表名


######################################### dql ##############################################

1.0 :数据查询语言
2.0 用来查询数据
3.0 查询的都是虚拟结果集
4.0 也就是 每次查询的表并不会保存
5.0 类型存放在内存当中
6.0 根据查询内容的不用
7.0 自动生成 对用的结果集

--- 查看数据库
    show databases;

--- 查看当前数据库
    select database();

--- 查看表
    show tables；

--- 查看表结构
    desc xxx

--- 查看已经创建的原生表
    show create table student;

--- 查看表的所有字段的值
    select * form 表名；

--- 查看 指定字段的 值
    select 字段1,字段2 from 表名；

******* 条件查询 where 

    逻辑条件 或与非 大于 等于 小于 大于等于 小于等于
--- between  and; 范围查询
--- in(set1,set2,set3)固定的多选值 ;
--- is null; 为空
--- is not null； 不为空
--- = 
--- != 
--- <=
--- >=
--- and 与
--- or 或
--- not 非


******** 模糊查询where like

--- select * from 表名 where 字段 like '[1-9a-z]_xx%';

    _ 下划线代表任意一个字符
    % 百分号代表任意的多个字符 对字符个数没有限制
    [] 和正则表达类似
    [^] 代表取反

******** 查询去重
    如果查询的结果有重复 那么就会取其中一个
--- select id,distinct 查询字段 form 表名；


******** as 给查询的字段起一个别名
--- select id as uid from 表名;


******** 让查询的结果 参与运算
--- select id + age from 表名;


******** 判断如果查询的结果为空 null
--- select ifnull(id,value) from 表名


******** 对查询的结果 根据指定的字段 进行升序 或者 降序
    默认是升序

--- select * from 表名 order by 字段1 排序,字段2 排序;

    如果第一个相等，那么就会按照第二个进行排序;

*************** 多表查询 

--- union 

    操作符用于连接两个以上的 select
    语句的结果组合到一个结果集合中。多个 select 语句会删除重复的数据

--- select expression1, expression2, ... expression_n
    from tables
    [where conditions]
    union [all | distinct]
    select expression1, expression2, ... expression_n
    from tables
    [where conditions];

--- 多表查询
    同时查询 多个表中的数据

    select * from 表1,表2;

    这样 就会出现问题
    表一的查询的字段会在表二中重复匹配
    因此 我们可以用几个 方法 来 避免这种现象

    方式一 
    -- 99式 
    select 字段1 别名,字段2 别名 from 表1，表2 where 表1.一致的字段 = 表2.一致的字段；

    方式二
--------内连接 
    --等值查询
    和99 类似 只不过换种写法
    join on

    select 字段一 别名，字段二 别名 from 表1 join 表2 on 表1.关联的字段 = 表二.关联的字段;

    如果 join on 
    还想在添加条件 
    就在后面继续用
    where 添加条件
    多表用 多个join on 连接即可

-------- 左外连接和右外连接
    左连接 会把 左边的表 查询的字段全部查出来
    右边的 只差符合 on 后面的 条件的
    右连接 相反
    left join  on
    right join  on

-------- 自然连接
    自然连接 必须确保两个表有相同字段
    字段的名称 和 类型必须一致
    他会自动查询一致字段的 查询值
    不用在手动设置参数

    selec * from 表1 natural 表2；

********** 子查询
    
    把查询的结果 在一次当作 表 或者条件
    放到一个查询语句中
    用括号括起来
    --- 查询的结果放到 from 后面
        就会当作一个表再次查询

    select * from 表1
    select 字段 from (select * from 表一)

    --- 查询的结果放到 where后面 就会把 他当作 条件
    select * from 表1;
    select 字段 from 表2 where 条件 in (select * from 表1);

    --- 自然连接 
    就是把自己 当作 两个表进行查询
    分把 用一个表 起两个名字
    select * from 表1 名1 , 表1 名2；
    
********** 流程控制
--- case 
--- if
--- ifnull
--- nullif
    
    if(表达式，如果成立执行，如果不成立执行)
    select if(age>18,"成年","未成年") from student;

    ifnull(是否为空,如果为空执行)
    selecgt ifnull(age,0) from stduent;

    nullif

*********** 聚合函数 和 常用函数
--- 聚合函数 
    –count：统计行数量
    –sum：获取单个列的合计值
    –avg：计算某个列的平均值
    –max：计算列的最大值
    –min：计算列的最小值
--- 常用函数
    concat() 将值转换成字符串 连接成一个整体 但是与null 连接 都为null
    insert(str,x,y,instr) 把一个字符串 的 x 位置 的后面 y个 替换成 instr；
    lift(str,x) 和 right(str,x) 把字符串从 左边或者右边 或者去 x 个 如果x 为null 不返回任何值


************* 分组
--- group by 指定字段
    用group_concat('字段') 可以累出每个组的字段
    后面还能继续添加聚合函数 对分组内的数据进行处理


    分组注意点 一般前面查询的字段
    最好都在后面进行分组

    select 字段一,字段二 from student group by 字段一，字段二；
    
--- group by + 聚合函数
    用来处理分组内的数据

    select 字段一，聚合函数 from student group by 字段一；

--- group by + where 
    在分组之前 对 数据进行 过滤 然后 分组
    where 后面不能有聚合函数

    select 字段1 from 表 where id = 1 group by 自断一；

--- group by + having
    在分组之后对数据进行过滤
    selec 字段1 from 表 where id = 1 group by 字段一 having 筛选
    后面可以用聚合函数 进行筛选

--- limit 可以指定从几行 开始取 取几行
    select * from 表 limet 2,3

    可以用于网站的分页查询
    公式
    curretpage = 1 当前行
    currentsize = 3 取几行
    当前页为1 第一页从第0行开始取
    (1-1) *3 = 0
    (2-1) *3 = 3
    (3-1) *3 = 6
    (4-1) *3 = 9
    select * from 表 limit (currentpage - 1)，currentsize;
########################################  dcl ################################## 

1.0 数据控制语言
2.0 用来定义访问权限和安全级别


######################################### 数据类型 #############################

******** 数值类型

******** 字符串类型

******** 日期和时间类型

******** 空间数据类型

******** json 数据类型

******** 常用的数据类型

--- double 浮点型
    例如dauble(5,2)表示最多五位，其中必须有二位小数
    最大值 999.99
--- char ：固定长度字符串类型
    char(10) 固定是个字符
    如果没有十个就会用空格补全

--- varchar :可变长度的字符类型
    varchar(10) 规定最大字符长度
    具体的长度 跟实际字符的长度

--- text 字符串类型
    可以储存文本之类
    用 '' 括起来

--- blob ：二级制类型
    电影,图片，音频 等deg

--- date：日期类型
    格式 yyy-mm-dd

--- time: 时间类型
    格式 hh-mm-ss

--- datetime: 日期时间类型
    yyy-mmm-dd hh-mm-ss

################################ 数据完整性 ############################################


*********************  实体完整性

    1.0 表中的每一行 就是一个实体
    2.0 实体完整性，表示每一行的数据不重复
    3.0 他是行级约束

--- 查看表中的约束
    use information_schema;
    select constraint_name from table_constraints where table_name='student';

--- 约束类型

    1.0 主键约束（primary key）
        每个表中要有一个主键
        数据唯一，不能为null
        -- 方式一
            给一个字段添加一个主键 

        create table 表(字段1 类型 primary key,字段2 类型,)

        -- 方式二 联合主键
            设置的主键同时相同的时候才违反主键约束

            create table 表(字段1 类型,字段2 类型,primary key(字段1，字段2))

        -- 方式三 给已经创建好的表添加主键约束
            但是添加主键的字段必须符合约束，不然添加失败

            alter tablse 表 add constraint 约束名字 primary key(字段1,字段2);
        --- 方式四
            用关键字添加给表
            ceate table 表 (字段一,字段二, constarint 约束名字 primary key(字段1,字段二))
                
        --- 删除 约束用 alter drop primary key 语句

        --- 通过删除主键名字 来删除主键
            删除前 需要删除自增长 不然删不掉

            alter table 表名 drop 主键名 


    2.0 唯一约束（unique）
        约束这个字段 下的所有 值 不能重复
        可以为 null

        方式一 ：create table 表(id bigint,name varchar(15) unique)

        方式二 ：create table 表(id)

        --- 删除 用 alter drop change 更新一下
            或者 alter drop index unique字段

    3.0 自动增长列（auto_increment）
        1.0 指定字段下的 数据自增
        2.0 即使数据删除 下次添加仍然在被删除的基础上自增
        无论是添加失败 还是删除 都会被自增
        3.0 自增的表必须设置有 主键约束 或者 唯一约束
        不然不能设置自增

        create table 表 (字段一 auto_increment);

********************* 域完整性

    域完整性 主要针对 一个单元格的约束

--- 1.0 非空约束 not null
        不能为空
    creaet table 表 (id int(3) not null auto_increment) 

--- 2.0 默认约束
    create table 表 (字段 类型 default '默认值');

--- 3.0 数据类型 约束
    指定 数据类型
--- 4.0 检查约束
    enum(值1,值2) 枚举对象 每次选里面的和一个
    set(1,2,3,4) 一次可以选多个

********************* 多表约束

--- 外键 可以关联两个表的数据
    保证表的数据完整性
    主要是约束 关联表的删除 修改 和 增加
    不约束查询

    1.0 外键的类型 一定要和 关联表的字段的类型一致
    -- 方式一
    create table 表1（字段1,字段二,constraint kf_biao1_biao2 foreing key(外键字段) references biao2(关联的字段);

    -- 方式二
    给已经创建的表添加外键
    alter table 表 add constraint 外键名称 foreing key(外键) references 关联表（关联字段）;

--- 一对一的关系
    一个字段 对应一个字段

--- 一对 多的关系
    一个表关联在其他 关联表中 关联多条数据

--- 多对多的关系

    中间表 可以关联多个 表
    每个字段关联一个表

######################################### 事务 ###############################

 1.0 一组不可分割的操作 叫做事务
 2.0 事务只等你对ddl 生效
 3.0 事务的特性

    --- 原子性
        把步骤绑定到一起 
        要么成功
        要么失败

    --- 一致性
        同时完成

    --- 隔离性
        事务于事务之间 有隔离性的
        事务途中不能介入

    --- 持久性
        一旦确认 就会发生
    4.0 事务的使用

    --- 开启事务
        start transaction;

    --- 回滚事务
        rollback;

    --- 提交事务
        commit;

##################################  视图 ####################################

 视图就是把查询的表 存起来
 然后我们可以对这个视图表 进行操作
 视图可以提高数据安全性
 我们可以把 主表的重要数据过滤掉 保存一个视图
 共 其他用户查看

 --- 创建视图
    后面夹上 whit check option 表示如果要修改视图内容 必须符合查询基表时候的 条件

    create view 视图名称 ad (从真是的表中查询的表) with check option

 --- 修改视图
    等于把指定的视图 覆盖掉
    create or replace view 视图明 as （查询的表）;

 --- 删除视图
    drop view 视图名称

 --- 完整的视图格式
    merge 替换式 当视图的内容修改 那么基表的内容也会发生改变
    temptable 具化式 数据存在临时表当中 不能修改

    create [algorithm = merge(默认)|temptable(具化式)] view 视图名称 as （查询表) with check option;

 

############################### 存储过程 #####################################

 存储过程就是把常用的 操作 包装起来
 方便重复使用
 也就是对mysql 进行编程


 1.0 我们为了避免程序检测到 ;号 就执行 可以改为其他符号
    执行完毕后 在重新改回
    delimiter 自定义符号

 2.0 创建存储过程

 create procdeure 名称()
     begin

        代码块。。。。

     end 结束符号
 调用 call 存储过程名称()

 3.0 在存储过程中声明变量 set 给变量赋值

 declare 变量名 类型 default ；
 set 变量名 = 值 

 ---  用 select into 的方式复制变量

 select 查询结果 into 变量 from 表名；


 ############################### 索引 ###################################


 










# 1.0 垃圾回收机制可以干掉 引用计数器不能解决的 循环引用问题
# 
# 2.0 python 内存管理机制 收集所有的容器对象 通过双向链表 储存在一个集合当中 
# 
#     并且记录每个对象的引用次数，当引用指针为0时，说明这个对象外界已经
#     没有指针指向这个对象，那么系统就会释放这个对象的内存，但是如果这个对象
#     仍然引用着另一个对象那么他引用的对象的计数就会加一，另一个对象内部也引用这个对象 那么
#     这个对象内部也会加一，他们外界被引用的指针已经没有了，但是内部的引用让他们的引用计数仍然为1
#     所以不会被释放，这样就形成了循环引用,而垃圾回收机制可以检测这种循环引用
#     并释放他们
#     
#     
# 3.0 如果程序创建的很多个对象系统的内存机制都要依次检测的话 非常消耗性能
#       所以就会残生产生一种机制 对存活时间越长的对象 降低检测频率 
#       根据这种检测需求 产生出一个内存检测机制
#     --- 分带回收机制 
#          一共分为三代 0带 1带 2带 存活率越高 就会被分到相对 高的带从而减少 检测频率，提高性能
#          0带 当对象被创建出来的时候会被放到 0带当中 当 0带 检索次数达到 某次的话 如果 这个对象仍然
#          没有被释放 那么他就会被移动到1 带 当0带达到某个检测次数 才会检测1带 一次往后类推 到2带
# 4.0 并不是只要对象只要创建出来 垃圾回收机制 就会进行检测 
#     注意 
#     --- 而是当新增的对象个数 - 被释放的对象个数 超过 一定阀门值时候 会触发垃圾回收机制 来检测对象
#     
#     --- 我们可以通过gc 模块里面的 get_threshold() 来检测这个触发垃圾回收机制的阀值，这个阀值越大
#          消耗越小
#          (700, 10, 10) 返回的是一个元组 第一个元素是 垃圾检测 0带的阀值 如果达不到 就不会触发垃圾回收机制
#          第二个 参数是 1带 他的意思 是当 0带 检测10次 才后 触发 1带 检测 
#          同理 第三个参数 是2带 当1 带检测到10次的时候 就会触发 2 带检测
#      --- 我们 可以可以通过 gc.set_threshold(200, 5, 5) 这个方法来设置这些阀值
#           从而 提高效率
#      --- 默认的垃圾回收机制 是打开的 如果上述 达到阀值 会自动触发 
# 5.0  我们也可以监听垃圾回收机制是否打开 打开 和关闭,分别通过一下方法 实现
#       --- gc.enable() 开启垃圾回收机制 (默认是打开的) 当阈值达到时会自动触发
#       --- gc.disable() 关闭垃圾回收机制
#       --- gc.isenalbe() 检测垃圾回收是否开启
# 6.0 上面我们将的 垃圾回收机制 是自动触发的，当垃圾回收机制 开启并且达到一定阈值的时候 会自动触发
#      我们 也可以手动触发 
#      手动触发垃圾回收机制 不管 是否开启 都会触发垃圾回收机制
#      ---gc.collect([generation]) 里面的可选值 是值 触发那一带的 垃圾回收机制
#       0 代表0带
#       1 代表 0 和 1带
#       2 代表 0 1 2 带
#       如果没有就是全部清理
#       
# 7.0 其实我们完全可以避免 循环引用的发生 ，直接让对象在内存管理的引用计数机制来释放没有引用的对象
#     从而提高性能。
#     首先要知道 引用有两种类型 弱引用 和 强引用
#     --- 弱引用是指当一个容器对象指向另一个对象的时候，虽然建立引用 但是不会增加这个对象的
#      引用次数
#     --- 强引用 是指 当一个容器对象一引用另一个对象的时候，另一个对象的引用次数会增加
#     1.0 但是在为了确保 循环引用功能的完善(比如说 小黑 是 小花的一条狗， 小花是小黑的主人)
#     我们可以在 在引用上面预防 循环引用的发生，引用的时候用弱引用不会同时增加两个容器对象
#     内部相互引用造成的双方引用计数 同时加 1 从而不能用引用计数机制进行 释放的 问题
#     因为当两个内部相互引用的对象 其中一个引用是弱引用 那么 引用指针就会 为 0 就会被释放
#     当被释放对象 消失后 他指向的对象 引用计数 也会减一 也为0 也会被释放
#     --- weakref 模块里面的 ref()方法 可以建立弱引用
#         但是这个方法 只可以建立单个 弱引用
#         如果如果 引用的是一个 字典对象 我们 需要建立多个弱引用的时候
#         可以用
#     --- weakref.WeakValueDictonary({...}) 这个方法 可以给字典里面的每个 对象建立弱引用
#     
#      2.0 可以在取消两个相互引用的容器对象的外部引用后，然后手动改变其中一个引用，让其 指向None
#      也可以达到 销毁 循环引用的目的 
 # 
import objgraph
import gc
import weakref
class Persen:
    pass
class Dog:
    pass
p = Persen()
d = Dog()
# 建立弱引用
# p.dog = weakref.ref(d)
# 给多个对象建立弱引用
p.dog = weakref.WeakValueDictionary({"dog":d})
d.persen = p
print(objgraph.count("Persen"))
print(objgraph.count("Dog"))
del p
del d

# 手动进行垃圾回收机制
# gc.collect()
print(objgraph.count("Persen"))
print(objgraph.count("Dog"))
# print(gc.get_threshold())
# # gc.set_threshold(200, 5, 5)
# # gc.disable()
# # print(gc.isenabled())

class Persen:
    name = "bruce"
    _age = 18
    __sex = "女"
    # 公有化属性
    def run(self):
        print(Persen.name,"公有属性,类的内部访问")
        print(self.name,"公有属性,实例访问")
        print(Persen._age,"受保护属性,类的内部访问")
        print(self._age,"受保护属性,实例访问")
        print(Persen.__sex,"私有属性,类的内部访问")
        print(self.__sex,"私有属性,实例访问")
class Persen1(Persen):
    def run1(self):
        print(Persen1.name,"公有属性，子类内部访问")
        print(self.name,"公有属性，子类实例访问")
        print(Persen1._age,"受保护属性，子类内部访问")
        print(self._age,"受保护属性，子类实例访问")
        # print(Persen1.__sex,"私有属性，子类内部访问")
        # print(self.__sex,"私有属性，子类实例访问")

# --- __all__ 可以规定跨模块访问的变量

# __all__ = ["_age","name","__sex"]        
name = "跨模块访问，公有变量"
_age = "跨模块访问，受保护变量"
__sex = "跨模块访问，私有变量"
me = Persen()
me.run()
me1 = Persen1()
me1.run1()
print(Persen.name,"公有属性，模块其他位置类访问")
print(me.name,"公有属性，模块其他位置实例访问")
print(Persen._age,"受保护属性，模块其他位置类访问")
print(me._age,"受保护属性，模块其他位置实例访问")
# print(Persen.__sex,"私有属性，模块其他位置类访问")
# print(me.__sex,"私有属性，模块其他位置实例访问")
print(Persen1.name,"公有属性，模块其他位置子类访问")
print(me1.name,"公有属性，模块其他位置子类实例访问")
print(Persen1._age,"受保护属性，模块其他位置子类访问")
print(me1._age,"受保护属性，模块其他位置子类实例访问")
# print(Persen1.__sex,"私有属性，模块其他位置子类访问")
print(me1._Persen__sex,"私有属性，模块其他位置子类实例访问")
print(Persen.__dict__)

# ###################################  私有化属性 #####################################
# 
# 1.0 私有化属性可以限制对象属性的访问范围
# 
# 2.0 私有化属性(方法)可以保证数据安全，
# 
# 3.0 类属性(方法) 和 实例(方法)属性的私有化遵循相同的规则
# 
# 4.0 私有化属性的机制 是名字重整（NameMangling）
#     当我们创建私有化属性的时候
#     系统会自动改变这个私有化属性的名称
#     把原先的名字__sex 改成
#     _类名__sex 这个样
#  
#  5.0 私有化属性的目的是：
#       1.0 防止外界调用他
#       2.0 放置子类同名属性覆盖
#       
# ---------- 私有化属性的访问
# 
# --- 如果真的需要访问私有化属性，那么可以根据pyton私有化 重命名规则来进行访问
#      也就是访问改变后的属性名称 由于各个版本 重命名规则的不同，可以根据不同版本
#      的规则就访问
#      但是既然已经私有化了那就不要在外界去访问这个私有化属性
#     
# 
# ******************** 类的方位区域
# --- 类内部访问
#       公有属性 --- 可以
#       保护属性 -- - 可以   
#       私有属性 --- 可以
#       
# --- 子类内部访问
#       公有属性 --- 可以
#       保护属性 -- - 可以
#       私有属性 --- 不可以 
#       
# --- 实例内部访问
#       公有属性 --- 可以
#       保护属性 -- - 可以 
#       私有属性 --- 不可以
#       
# --- 模块内部其他位置访问
#       公有属性 --- 可以
#       保护属性 -- - 可以 [但是会警报]
#       私有属性 --- 不可以
#       
# --- 跨模块访问(其他模块内部访问是否能访问这个类型的变量)
#       公有属性 --- 可以
#       保护属性 -- - 可以 [但是会警报] 如果__all__ = [] 这个列表规定 跨模块访问的变量
#       私有属性 --- 如果使用 如果使用import 可以访问 或者用__all__ = []
#       
# ******************** 对象属性的 种类
# 
# --- x 公有属性
#     两边没有下划线，这个属性的访问权限很低
# 
# --- _y 保护属性 前面有一个下滑线
# 
# ---__z 私有属性 前面有两个下划线
# 
# --- h_ 在后面添加一条下划线 是为了区分关键字 的规范写法
# 
# --- __u__ 在两边添加 双下划线，一般是系统内置方法
# 
# ##################################### 私有化属性的应用场景 ################################
# 
# 1.0 私有化属性可以应用在,数据保护
# 2.0 也可以用于 数据过滤

#--- __init__ 用他去命名实例方法，可以用于实例的初始化操作。
#    当每个实例化对象的时候，都会自动调用这个初始化实例方法，
#    这个方法可以给每个实例化对象的属性，初始化赋值，
#    初始化实例属性

class Dog:
    """
    docstring for Dog
    1.0 __init__实例方法初始化的__age 是私有属性
        所以在类的外面是不能修改 和 获取 它的值，
        那么，我们可以通过在类里面创建 修改 和 获取这个私有属性的 实例方法 
        用实例调用 这个些方法进行修改 和 获取
    2.0 也可以在 这个私有属性的 这只方法上 过滤 设置的值
        过滤 也是 私有化属性的 用途之一
    """
    def __init__(self):
        self.__age = 18
    def setAttr(self,val):
        """
        设置私有化属性的实例方法，
        var : 要设置的参数 必须是一个 0 - 120 int类型的数值
        """
        if isinstance(val, int) and 0 < val < 120:
            self.__age = val
        else:
            print("您的输入有误，请重新输入")
    def getAttr(self):
        """
        获取私有化属性的值的方法
        var：需要获取的私有化属性
            var 必须是一个 私有化属性，
        """
        print(self.__age)
        
hei  = Dog()
hei.setAttr(0)
hei.getAttr()


        
        
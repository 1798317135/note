# 计算机是以cpu，承担了所有的计算任务
# 一个cup 在一个时间切片里只能运行一个程序
# 
# -----进程和线程都是cpu的执行单位
# 1.0 进程是cpu最小的分配单位（打开，执行，保存。。）
# 2.0 线程执行程序时候的最小调度单位(执行a,执行b)
# 3.0 一个程序至少有一个进程,一个进程至少有一个线程
# 
################# 并行 和 并发 ###########
#
# 并行：多个cpu核心，不同的程序就分配给不同的cpu来运行。
# 可以让多个程序同时执行。
# cpu1-----------
# cup2-----------
# cpu3-----------
# cpu4-----------
# 
# 并发：单个cpu核心,在一个时间切片里一次只能运行一个程序
# 如果同时运行多个程序，则串行执行。
# cpu1 --- ----
# cpu2 --- ----
################# 多进程 和 多线程 和协程###########
# ----- 多进程/多线程
# 表示可以同时执行多个任务，进程和线程的调度是由操作系统来完成的。
# --进程：每个进程都有自己独立的内存空间，不同进程之间内存不共享
# 共享意味着竞争,导致数据不安全,为了保护空间内存的数据安全，引入互斥锁
# 一个线程在访问的内存空间的时候，其他线程不允许访问,必须等待之前的线程结束
#才能使用这个内存空间
#--- 互斥锁：
#      一种安全有序的让多个线程访问内存空间的机制
# --- Python的多线程：

#GIL 全局解释器锁：线程的执行权限，在Python的进程里只有一个GIL。
# 一个线程需要执行任务，必须获取GIL。
# 好处：直接杜绝了多个线程访问内存空间的安全问题。
# 坏处：Python的多线程不是真正多线程，不能充分利用多核CPU的资源。
# 但是，在I/O阻塞的时候，解释器会释放GIL。
# 所以：

# ---多进程：密集CPU任务，需要充分使用多核CPU资源（服务器，大量的并行计算）的时候，用多进程。 multiprocessing
# 缺陷：多个进程之间通信成本高，切换开销大
# 
# --- 多线程：密集I/O任务（网络I/O，磁盘I/O，数据库I/O）使用多线程合适。
# threading.Thread、multiprocessing.dummy
# 缺陷：同一个时间切片只能运行一个线程，不能做到高并行，但是可以做到高并发
# ---协程：又称微线程，在单线程上执行多个任务，用函数切换，开销极小。不通过操作系统调度，
# 没有进程、线程的切换开销。genvent，monkey.patchall
# 多线程请求返回是无序的，那个线程有数据返回就处理那个线程，而协程返回的数据是有序的。

# 缺陷：单线程执行，处理密集CPU和本地磁盘IO的时候，性能较低。处理网络I/O性能还是比较高.
# tcp时面向连接的传输控制协议
# 客户端和服务器 要建立tcp连接 需要三次握手，和四次挥手
# 所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。

import socket
# --- 三次握手
# 三次握手的目的是连接服务器指定端口，建立TCP连接,
# 并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手。

# 一次握手 ： 客户端向服务器发送一个 syn包(SYN=j)，然后客户端进入SYN_SEND状态
# 二次握手： 服务器收到客户端发送的SYN(ACK=j+1)包 并保证加一,同时服务器也会向客户端发送一个SYN(SYN=K)，并进入SYN_recv状态
# 三次握手: 客户端收到这个服务器的SYN+ACK包，然后向服务器发送确认包ACK(ACK=k+1)，此时客户端和服务器建立连接 完成三次握手

# --- 四次挥手
# 
# 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。
# 这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，
# 一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
# 一次挥手:客户端发送一个FIN，用来关闭客户端到服务器的数据传输(报文一)
# 二次挥手:服务器接收到客户端的FIN ,然后发回一个ACK，确认序列号为收到的序列号加一，和SYN一样 每个FIN占用一个序列号
# 三次挥手：服务器关闭与客户端的连接，发送一个FIN给客户端
# 四次挥手：客户端发回一个ACK报文确认，并将序列号设置为收到的序列号加一
# 
# ---- TIME_WAIT状态
# TIME_WAIT状态也称为2MSL状态
# 他的意思就是 也就是报文最大生存时间
# 当TCP连接完成四个报文段的交换时，主动关闭的一方将继续等待一定时间(2-4分钟)，
# 即使两端的应用程序结束
# 
#  作用 ：其一，保证ACK会成功发送到对方，当超过时间没有接收到 对方的确认信息，那么会启动超时重传
#  
 # 影响：当连接的一端处于 TIME_WAIT状态的时候，将不能在被使用，
 # 也就是说 当我们强行关闭 一端的连接，那么我们就无法，重新使用bind()这个端口，他事实上并没有结束 而是出入TIME_WAIT状态
 #  解决这个问题的一个方法就是设置socket的SO_REUSEADDR选项。这个选项意味着你可以重用一个地址。也就是时服务器可以在2MSL内启动listen
 #  但是对于客户端来说，虽然可以绑定成功 但是在windows系统下，connect（）会失败
 #  要解决windows平台的这个问题，可以设置SO_LINGER选项
 #  lose时TCP连接会立刻断开，TCP不会将发送缓冲中未发送的数据发送，而是立即发送一个RST报文给对方，这个时候TCP连接就不会进入TIME_WAIT状态。如你所见，这样做虽然解决了问题，
 #  但是并不安全。通过以上方式设置SO_LINGER状态，等同于设置SO_DONTLINGER状态。
 #  
 #  当TCP连接发生一些物理上的意外情况时，例如网线断开，linux上的TCP实现会依然认为该连接有效，而windows则会在一定时间后返回错误信息。
 #  这似乎可以通过设置SO_KEEPALIVE选项来解决，不过不知道这个选项是否对于所有平台都有效。
 #
 #Tcp的大概流程

# ####### 建立套接字的方法
# ---客户端
# 1.0 创建套接字对象
# 2.0 调用connect()方法 和服务器建立连接
# 3.0 收发数据
# 4.0 关闭套接字
#
#--- 服务器
# 1.0 创建套接字
# 2.0 设置套接字
# --- socket.setsockopt(level,optname,value)
#     level level定义了哪个选项将被使用。通常情况下是SOL_SOCKET，意思是正在使用的socket选项。
#     optname参数提供使用的特殊选项。
#             SO_REUSEADDR 当socket关闭后，本地端用于该socket的端口号立刻就可以被重用
#             SO_OOBINLINE 也就是说会通过一个标准的对recv()的调用来接收这些数据
#             SO_KEEPALIVE 可以使TCP通信的信息包保持连续性
#             SO_DONTROUTE禁止通过路由器和网关往外发送信息包。   
#             SO_BROADCAST 允许广播地址发送和接收信息包。只对UDP有效。
#             SO_BINDTODEVICE 可以使socket只在某个特殊的网络接口（网卡）有效。
# S.setsockopt(SOL_SOCKET,SO_REUSEADDR,True) # 值为True时关闭服务器进程 里面释放端口，而不会等待2MSL
# solist=[x for x in dir(socket) if x.startswith('SO_')]
# solist.sort()
# for x in solist:
#     print(x) 可以给出在某个系统下 python 支持的选项

# 3.0 绑定地址端口
# 4.0 监听连接
# 5.0 连接新用户
# 6.0 收发数据
# 7.0 关闭新用户
# 8.0 关闭套接字

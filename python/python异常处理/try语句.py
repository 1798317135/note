# try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，
# 这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。

# 如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，
# 异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。
# 如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，
# 或者到程序的最上层（这样将结束程序，并打印缺省的出错信息）。
# 如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），
# 然后控制流通过整个try语句。
# 
# --- raise [Exception [, args [, traceback]]] 抛出异常
#           第一个参数 抛出的 异常类型，args 参数 tracback 跟踪异常对象
# raise NameError("sdf")
# try:
#     pass
#     # 可能会出现异常的代码
#     # 这里可能会抛出多个异常，检测顺序是从上到下
#     # 当检测到第一个异常的时候 直接往下语句走，
#     # 不会接着检测下一个错误

#     it = iter("a")
#     print(next(it))
# except Exception as e:
#     # Exception 是异常的类别，e 是接收异常的形参
#     # Exception 也是一个上下文 管理器  e是 __enter__ 方法 返回的 值
#     # 如果是直接设置为 Exception 则接收所有类别的错误
#     # 如果想捕获多个自己 指定的类别 可以用 ()括起来，组成一个元组 ，e则返回捕获到那个类别返回的信息
#     # e 可以返回 这个错误类 返回的 值
#     # 这个语句可以写多次 来给多个捕获的类型 添加处理语句块
    
#     print("ad")
#     # 对于这个异常的处理
# else:
#     pass
#     print("456")
#     # 当没有出现异常的处理的代码块
#     # 也可以省略
#     # 这一块，必须except 结束以后 
# finally:
#     pass
#     print("123")
#     # 不管有没有出现异常都会执行的代码
#     # 这一块必须放到最后 
#     # 也可以省略
import traceback

